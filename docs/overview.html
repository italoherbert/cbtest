<!DOCTYPE html>

<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Página oficial do xutest - overview - visão geral">
    <meta name="keyworks" content="xutest, testes, unitários, unidade, unit, test, windows, linux, cbuild, c, c++">
    <meta name="author" content="Ítalo Herbert Siqueira Gabriel">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css" rel="stylesheet">
    <link href="lib/fontawesome/all.min.css" rel="stylesheet">
    <link href="lib/prism/prism.css" rel="stylesheet">
    <link href="style/style.css" rel="stylesheet">
    
    <title>Visão Geral - xutest - Página oficial</title>

    <script src="lib/jquery-3.7.1.min.js"></script>    
    <script src="lib/fontawesome/all.min.js"></script>
    <script src="js/main.js"></script>
</head>

<body>    
    <nav id="nav"></nav>
    
<div class="d-flex flex-nowrap">
    <aside id="aside"></aside>
    <main>
        <section>
            <h1 class="text-center">Visão Geral</h1>

            <br />

            <p>O xutest pode ser utilizado para criação e execução de testes unitários 
            em C/C++.</p>

            <section>
                <h3>Instalação</h3>

                <p>Para instruções de como instalar o xutest, acesse: 
                    <a href="downloads.html#how-install">como instalar</a>.
                </p>
            </section>

            <article id="first-example">
                <header>
                    <h3>Um primeiro exemplo</h3>
                </header>

                <p>Crie o arquivo "main.cpp" em seu projeto com o seguinte conteúdo:</p>

<pre class="line-numbers"><code class="language-cpp">#include &lt;xutest/xutest.h&gt;

TEST_CASE( primeiroTeste, Testes ) {
    int a = 1;
    int b = 1;
    int c = 2;
    ASSERT_EQUALS( a, b, )
    ASSERT_TRUE( a == b, )
    ASSERT_FALSE( a == c, )
}

int main() {
    RUN_ALL_TEST_CASES();
    return 0;
}
</code></pre>                 

                    <p>Agora compile o projeto acima com o seguinte comando: </p>

                    <p>Se estiver no windows faça: </p>
<pre><code>g++ -o main.exe main.cpp -lxutest </code></pre>
                    <p>Se estiver no linux faça: </p>
<pre><code>g++ -o main main.cpp -lxutest -ldl -rdynamic</code></pre>

                    <p>Se estiver no linux, não esqueça das opções -ldl e -rdynamic.</p>

                    <p>Agora execute o executável criado que tem o nome "main", se 
                    estiver no linux e "main.exe", se estiver no windows. Exemplos: </p>

                    <p>Se estiver no windows faça: </p>
<pre><code>.\main.exe</code></pre>
                    <p>Se estiver no linux faça: </p>
<pre><code>./main</code></pre>

                    <p>Agora você deve visualizar a seguinte saída: </p>

                    <figure>
                        <img src="images/helloworld-output.png" />
                    </figure>
                
            </article>

            <article id="multiples-test-files">
                <header>
                    <h3>Multiplos arquivos de teste</h3>
                </header>

                <p>Se precisar dividir os testes em vários arquivos. Por exemplo, um 
                arquivo por classe de casos de teste, pode fazer conforme a seguir:</p>

                <p>Suponha que agora você tem o arquivo "main.cpp" e o arquivo "tests.h", 
                veja abaixo o conteúdo de "test.h": </p>

                <b><i>tests.h</i></b><br />
<pre class="line-numbers"><code class="language-cpp">#include &lt;xutest/xutest.h&gt;

TEST_CASE( test1, MyTests ) {
    ASSERT_EQUALS( 1, 1, )
}

TEST_CASE( test2, MyTests ) {
    ASSERT_TRUE( true, )
}

TEST_CASE( test3, MyTests ) {
    ASSERT_NULL( nullptr, )
}
</code></pre>

                <p>Agora vamos para o conteúdo do arquivo "main.cpp": </p>

                <b><i>main.cpp</i></b><br />
<pre class="line-numbers"><code class="language-cpp">#include "tests.h"

#include &lt;xutest/xutest.h&gt;

int main() {
    RUN_ALL_TEST_CASES()
    return 0;
}
</code></pre>

                <p>Perceba que o arquivo "tests.h" está sendo incluído em "main.cpp", mesmo 
                sem ter uma de suas funções, métodos, classes, ou outro recurso diretamente 
                chamados no arquivo "main.cpp". Isso é obrigatório. Isto é, para que as definições 
                de casos de testes sejam encontradas, é necessária a inclusão do arquivo 
                "tests.h".</p>

            </article>

            <article id="RUN_TEST_CASES_MENU">
                <header>
                    <h3>A macro RUN_TEST_CASES_MENU</h3>
                </header>

                <p>A macro RUN_TEST_CASES_MENU, pode ser utilizada como alternativa a 
                RUN_ALL_TEST_CASES. A diferença é que RUN_TEST_CASES_MENU mostra um 
                menu para o usuário escolher se deseja mostrar todos os testes ou os testes 
                de uma determinada classe. Já RUN_ALL_TEST_CASES, mostra diretamente todos os 
                testes. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">#include &lt;xutest/xutest.h&gt;

TEST_CASE( teste, Testes ) {
    int a = 1;
    int b = 1;
    int c = 2;
    ASSERT_EQUALS( a, b, )
    ASSERT_TRUE( a == b, )
    ASSERT_FALSE( a == c, )
}

int main() {
    RUN_TEST_CASES_MENU();
    return 0;
}
</code></pre> 

            </article>

            <article id="cbuild-integration">
                <header>
                    <h3>Integrando com o cbuild</h3>
                </header>

                <p>Para integrar com o cbuild, basta criar o CBuildFile na raiz do 
                projeto e executar os testes com o cbuild e as seguintes tarefas: 
                test, testbuild ou testbuildall</p>

                <p>Para tanto, é necessário definir as propriedades <b>"src.dir", "test.dir"  
                e "test.libs"</b> no CBuildFile.</p>

                <p>Se estiver no linux, é necessário também definir a propriedade 
                "test.linker.params"</p>

                <p>Caso não tenha instalado o xutest e quiser incluí-lo manualmente no 
                projeto, precisa definir também as propriedades <b>"test.include.dirs", 
                "test.lib.dirs"</b>.</p>

                <p>Se o xutest já estiver instalado no sistema operacional, não precisa definir 
                as propriedades <b>"test.include.dirs", "test.lib.dirs" e "test.libs"</b>.</p>

                <p><b>Atenção</b>: A propriedade <b>"src.dir"</b> deve ser definida e ter valor diferente do 
                diretório raiz do projeto ou parente dele.</p>

                <p>Após configurado o <b>CBuildFile</b> com os caminhos dos includes, lib do xutest e 
                parâmetros para o comando que linka os arquivos de teste, é só criar os testes 
                na pasta da propriedade <b>"test.dir"</b>.</p>

                <p>Veja abaixo o exemplo de configuração básica do script <b>CBuildFile</b>: </p>

<pre class="line-numbers"><code>src.dir=src
test.dir=test
test.libs=xutest

IF os != "windows"
# interpretado somente se estiver no linux
test.linker.params=-ldl -rdynamic
ENDIF
</code></pre> 
                <p>O exemplo acima assume que a pasta de testes é a pasta <b>"test"</b>.</p>
                
                <p>Caso não tenha instalado o cbuild e quiser inclur manualmente, faça 
                conforme o seguinte exemplo: </p>

<pre class="line-numbers"><code>src.dir=src
test.dir=test

test.include.dirs=include
test.lib.dirs=.
test.libs=xutest

IF os != "windows"
# interpretado somente se estiver no linux
test.linker.params=-ldl -rdynamic
ENDIF
</code></pre>                
    
                <p>O exemplo acima assume que o diretório onde deve procurar o arquivo 
                <b>"libxutest.a"</b> é o diretório corrente. Para outro diretório, é só 
                alterar <b>"test.lib.dirs"</b>. Claro, o exemplo acima assume que o nome da 
                static library do xutest tem o nome <b>"libxutest.*"</b>, onde o "*" geralmente 
                corresponde a "a" ou "lib". Esse exemplo assume também que a os arquivos 
                de cabeçalho do xutest estão na pasta <b>"include"</b>.</p>

                <p>Agora, seguindo o exemplo anterior, siga os seguintes passos: </p>
                
                <ol>
                    <li>crie uma pasta "src" e uma pasta "test".</li>
                    <li>Copie o arquivo "main.cpp" para a pasta "test".</li>
                    <li>Agora execute o seguinte comando:<br />

<pre><code>cbuild testbuildall</code></pre>

                        <p>Você deve ver agora a seguinte saída:</p>

                        <figure>
                            <img src="images/helloworld-cbuild-output.png" />
                        </figure>
                    </li>

                </ol>

            </article>

            <article id="include-in-project">
                <header>
                    <h3>Como incluir o xutest sem instalar</h3>
                </header>

                <p>Para incluír o xutest no projeto sem instalar, baixe o xutest da 
                página <a href="downloads.html">downloads</a>, e então, extraia o arquivo 
                baixado e coloque o arquivo "libxutest.a" e a pasta "include" na raiz do 
                seu projeto. Seu projeto helloworld deve ter agora a seguinte estrutura: </p>

<pre>
helloworld
├── include
│   └── xutest
│       ├── xutest.cpp
│       ├── xutest.h
│       ├── fexec
│       │   ├── fexec.cpp
│       │   └── fexec.h
│       ├── output
│       │   └── output.h
│       ├── sourcecode
│       │   ├── SourceCodeManager.cpp
│       │   └── SourceCodeManager.h
│       └── util
│           ├── io.cpp
│           ├── io.h
│           ├── strutil.cpp
│           └── strutil.h
├── libxutest.a
└── main.cpp  
</pre>

                <p>Agora execute o seguinte comando para compilar e linkar: </p>

                <p>Se estiver no linux faça: </p>

<pre><code>g++ -o main main.cpp -lxutest -L. -Iinclude -ldl -rdynamic</code></pre>

                <p>Se estiver no windows faça: </p>

<pre><code>g++ -o main.exe main.cpp -lxutest -L. -Iinclude</code></pre>

                <p>Foram acrescentadas as opções "-L." e "-Iinclude", onde, "-L." 
                especifica onde procurar pela static library. Nesse caso, a lib de 
                nome: "libxutest.a" que está na raiz do projeto. Por isso o ".". E 
                o "-Iinclude" especifica onde encontrar os arquivos header que, nesse 
                caso, está na pasta "include". A opção "-lxutest" deve corresponder ao 
                nome da lib, sem o prefixo "lib" e sem a extenção ".a". Isto é, "xutest".</p>

                <p>Agora você pode rodar o arquivo linkado: O "main.exe" se estiver no windows ou 
                "main", se estiver no linux e, então, visualizar o resultado.</p>
            </article>

            <article id="TEST_CASE">
                <header>
                    <h3>A macro TEST_CASE</h3>
                </header>

                <p>Na macro TEST_CASE, fica a escrita do caso de teste em si. Isto é, as 
                chamadas as macros de ASSERT.</p>

                <p>O primeiro argumento passado a TEST_CASE, é o nome do caso de teste e o 
                segundo argumento (opcional) é o nome da classe do caso de teste. Se não 
                quiser informar, o caso de teste é vinculado a classe de nome "default" e, 
                a virgula após o nome do caso de teste é obrigatória, mesmo que, após a virgula, 
                não seja definido o nome da classe do caso de testes. Veja o exemplo abaixo: </p>

<pre class="line-numbers"><code class="language-cpp">TEST_CASE( primeiroTeste, MeusTestes ) {
    ASSERT_EQUALS( 1, 1, )
}
</code></pre>

            </article>

            <article>
                <header>
                    <h3>As macros de assert</h3>
                </header>

                <p>As macros de assert suportam uma mensagem personalizada a ser mostrada 
                no caso do assert falhar e não precisam ser finalizadas com ponto e vírgula.</p>

                <p>No caso da macro ser chamada, por exemplo, dentro de um if/else sem blóco de 
                código, é obrigatório não colocar o ponto e virgula no final da macro. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">bool condicao = true;
    if ( condicao )
        ASSERT_EQUALS( 1, 1, );
    else ASSERT_EQUALS( 1, 2, )
</code></pre>

                <p>O exemplo acima está errado porque há um ponto e virgula após a macro de 
                assert, e antes do else do if. O correto é retirar o ponto e virgula como a 
                seguir: </p>

<pre class="line-numbers"><code class="language-cpp">bool condicao = true;
    if ( condicao )
        ASSERT_EQUALS( 1, 1, )
    else ASSERT_EQUALS( 1, 2, )
</code></pre>

                <br />

                <section id="ASSERT_EQUALS">
                    <h5>A macro ASSERT_EQUALS</h5>

                    <p>A macro de assert pode ser utilizada para testar se dois valores 
                    são iguais. Exemplos:</p>

<pre class="line-numbers"><code class="language-cpp">ASSERT_EQUALS( 1, 1, )

int a = 1;
int b = 1;
string c = "teste";
string d = "teste";

ASSERT_EQUALS( a, b, )
ASSERT_EQUALS( c, d, As strings não são iguais! )
</code></pre>          

                    <p>No exemplo acima, são comparadas duas variáveis inteiras e duas 
                    variáveis tipo string. Perceba que no último assert, é passada como 
                    terceiro argumento, uma mensagem. Essa mensagem é mostrada, apenas 
                    se o assert falhar. Perceba que a mensagem não está entre aspas duplas. 
                    As aspas duplas não são necessárias. Caso contrário, as aspas duplas 
                    também são impressas.</p>

                    <p>Perceba também que, os asserts sem a mensagem a ser mostrada em 
                    caso de falha, têm uma virgula após os parâmetros e antes do 
                    fecha parenteses. Essa virgula é necessária, mesmo que o terceiro argumento 
                    não seja informado. Isso vale para todas as macros de assert e a macro 
                    TEST_CASE.</p>
                </section>

                <br />

                <section id="ASSERT_NOT_EQUALS">
                    <header>
                        <h5>A macro ASSERT_NOT_EQUALS</h5>
                    </header>

                    <p>É o contrário da macro ASSERT_EQUALS. Isto é, falha se os valores 
                    forem iguais. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">string str1 = "teste";
string str2 = "teste2";

ASSERT_NOT_EQUALS( str1, str2, )
</code></pre> 

                </section>

                <br />

                <section id="ASSERT_EQUALS_ARRAYS">
                    <header>
                        <h5>A macro ASSERT_EQUALS_ARRAYS</h5>
                    </header>

                    <p>A macro ASSERT_EQUALS_ARRAYS pode ser utilizada para testar 
                    se dois arrays são iguais. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">int arr1[] = { 1, 2, 3 };
int arr2[] = { 1, 2, 3 };

ASSERT_EQUALS_ARRAYS( arr1, arr2, 3, )
</code></pre> 

                    <p>Os asserts de arrays recebem um terceiro parâmetro adicional: o 
                    tamanho do array. No exemplo acima, os arrays têm 3 elementos cada.</p>
                </section>

                <br />

                <section id="ASSERT_NOT_EQUALS_ARRAYS">
                    <header>
                        <h5>A macro ASSERT_NOT_EQUALS_ARRAYS</h5>
                    </header>

                    <p>A macro ASSERT_NOT_EQUALS_ARRAYS pode ser utilizada para testar 
                    se dois arrays são diferentes. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">int arr1[] = { 1, 2, 3 };
int arr2[] = { 3, 2, 1 };

ASSERT_EQUALS_ARRAYS( arr1, arr2, 3, )
</code></pre> 
                </section>

                <br />

                <section id="ASSERT_EQUALS_VECTORS">
                    <header>
                        <h5>A macro ASSERT_EQUALS_VECTORS</h5>
                    </header>

                    <p>A macro ASSERT_EQUALS_VECTORS pode ser utilizada para testar 
                    se dois vectors são iguais. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">vector<int> vect1 = { 1, 2, 3 };
vector<int> vect2 = { 1, 2, 3 };

ASSERT_EQUALS_VECTORS( vect1, vect2, )
</code></pre> 
                </section>

                <br />

                <section id="ASSERT_NOT_EQUALS_VECTORS">
                    <header>
                        <h5>A macro ASSERT_NOT_EQUALS_VECTORS</h5>
                    </header>

                    <p>A macro ASSERT_NOT_EQUALS_VECTORS pode ser utilizada para testar 
                    se dois vectors são diferentes. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">vector<int> vect1 = { 1, 2, 3 };
vector<int> vect2 = { 3, 2, 1 };

ASSERT_NOT_EQUALS_VECTORS( vect1, vect2, )
</code></pre> 
                </section>

                <br />

                <section id="set_print_vectors">
                    <h5>Atenção</h5>

                    <p>Você pode desabilitar, ou habilitar, a impressão dos vetores 
                    no caso de falha no assert. Isso é útil para evitar impressão de 
                    vetores, caso eles tenham muitos elementos, por exemplo.</p>

                    <p>Para habilitar, ou desabilitar a impressão de vetores 
                    (ou arrays) na falha do assert, utilize a seguinte função: </p>

<pre class="line-numbers"><code class="language-cpp">xutest::set_print_vectors( true ); // Para habilitar
xutest::set_imp_vectors( false );  // para desabilitar
</code></pre>

                    <p>Esta função <b>set_print_vectors</b> está no header <b>"xutest.h"</b> 
                    e no namespace <b>xutest</b>. Agora, veja abaixo dois exemplos: </p>

<pre class="line-numbers"><code class="language-cpp">xutest::set_print_vectors( true ); // Para habilitar

vector<int> vect1 = { 1, 2, 3 };
vector<int> vect2 = { 3, 2, 1 };

ASSERT_EQUALS_VECTORS( vect1, vect2, )
</code></pre>
                    <p>Os vetores são impressos, pois, o assert falha e a flag de impressão 
                    de vetores está setada para true. Setada através do método set_print_vectors</p>

<pre class="line-numbers"><code class="language-cpp">xutest::set_print_vectors( false ); // Para desabilitar

vector<int> vect1 = { 1, 2, 3 };
vector<int> vect2 = { 3, 2, 1 };

ASSERT_EQUALS_VECTORS( vect1, vect2, ) 
</code></pre>

                    <p>Os vetores não são impressos, pois, apesar de o assert falhar, a flag de impressão 
                    de vetores está setada para false.</p>
                </section>

                <br />

                <section id="ASSERT_TRUE">
                    <h5>A macro ASSERT_TRUE</h5>

                    <p>A macro assert true testa se uma condição é verdadeira. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">int a = 1;

ASSERT_TRUE( a > 0, )
</code></pre>
                </section>

                <br />

                <section id="ASSERT_FALSE">
                    <h5>A macro ASSERT_FALSE</h5>

                    <p>A macro assert false testa se uma condição é falsa. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">int a = 1;

ASSERT_FALSE( a == 0, )
</code></pre>
                </section>

                <br />

                <section id="ASSERT_NULL">
                    <h5>A macro ASSERT_NULL</h5>

                    <p>A macro ASSERT_NULL testa se o ponteiro aponta 
                    para nullptr ou NULL. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">string* strptr = nullptr;

ASSERT_NULL( strptr, )
</code></pre>
                </section>

                <br />

                <section id="ASSERT_NOT_NULL">
                    <h5>A macro ASSERT_NOT_NULL</h5>

                    <p>A macro ASSERT_NOT_NULL testa se o ponteiro não aponta, nem 
                    para nullptr, nem para NULL. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">string* strptr = new string( "abc" );

ASSERT_NOT_NULL( strptr, )
</code></pre>
                </section>

                <br />

                <section id="ASSERT_THROWS">
                    <h5>A macro ASSERT_THROWS</h5>

                    <p>A macro ASSERT_THROWS testa se uma determinada exceção foi lançada. 
                    Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">ASSERT_THROWS( runtime_error, {
    // Código qualquer
    throw runtime_error( "XXX" );    // lança uma runtime_error
}, );
</code></pre>
                </section>

                <section id="ASSERT_NOT_THROWS">
                    <h5>A macro ASSERT_NOT_THROWS</h5>

                    <p>A macro ASSERT_THROWS testa se uma determinada exceção não foi lançada. 
                    Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">ASSERT_NOT_THROWS( runtime_error, {
    // Código qualquer
}, );
</code></pre>

                    <p>O assert passa se o código dentro do bloco de código do ASSERT_NOT_THROWS 
                    não lançar uma exceção "runtime_error".</p>

                </section>
    
            </article>

            <article>
                <header>
                    <h3>As macros BEFORE_ALL e AFTER_ALL</h3>
                </header>

                <p>As macros BEFORE_ALL e AFTER_ALL, podem ser usadas para definir um 
                bloco de código que deve ser executado antes de todos os testes da classe, 
                ou, após todos os testes da classe, respectivemante.</p>

                <section id="BEFORE_ALL">
                    <h5>A macro BEFORE_ALL</h5>

                    <p>A macro BEFORE_ALL pode ser usada para definir o que deve ser 
                    executado antes de todos os testes da classe de casos de teste. 
                    Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">BEFORE_ALL( MeusTestes ) {
    cout &lt;&lt; "Iniciando os testes da classe de testes MeusTestes" &lt;&lt; endl;
}

TEST_CASE( teste1, MeusTestes ) {
    ASSERT_EQUALS( 1, 1, )
}

TEST_CASE( teste2, MeusTestes ) {
    ASSERT_TRUE( true, )
}
</code></pre>
                    <p>A mensagem do "cout" da definição BEFORE_ALL, é impressa antes de todos 
                    os testes da classe MeusTestes.</p>
                </section>

                <br />

                <section id="AFTER_ALL">
                    <h5>A macro AFTER_ALL</h5>

                    <p>A macro AFTER_ALL pode ser usada para definir o que deve ser 
                    executado depois de todos os testes da classe de casos de teste. 
                    Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">AFTER_ALL( MeusTestes ) {
    cout &lt;&lt; "Finalizando os testes da classe de testes MeusTestes" &lt;&lt; endl;
}
</code></pre>
                    <p>A mensagem do "cout" da definição AFTER_ALL, é impressa após de todos 
                    os testes da classe MeusTestes.</p>
                </section>
            </article>

            <article>
                <header>
                    <h3>As macros BEFORE_EACH e AFTER_EACH</h3>
                </header>

                <p>As macros BEFORE_EACH e AFTER_EACH, podem ser usadas para definir um 
                bloco de código que deve ser executado antes de cada caso de teste da classe, 
                ou, após cada caso de teste da classe, respectivemante.</p>

                <section id="BEFORE_EACH">
                    <h5>A macro BEFORE_EACH</h5>

                    <p>A macro BEFORE_EACH pode ser usada para definir o que deve ser 
                    executado antes de cada caso de teste da classe de casos de teste. 
                    Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">BEFORE_EACH( MeusTestes ) {
    cout &lt;&lt; "Iniciando execução do caso de teste" &lt;&lt; endl;
}
</code></pre>
                    <p>A mensagem do "cout" da definição BEFORE_EACH, é impressa antes de cada  
                    caso de teste da classe MeusTestes.</p>
                </section>

                <br />

                <section id="AFTER_EACH">
                    <h5>A macro AFTER_EACH</h5>

                    <p>A macro AFTER_EACH pode ser usada para definir o que deve ser 
                    executado depois de cada caso de teste da classe de casos de teste. 
                    Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">AFTER_EACH( MeusTestes ) {
    cout &lt;&lt; "Finalizando a execução do caso de teste" &lt;&lt; endl;
}
</code></pre>
                    <p>A mensagem do "cout" da definição AFTER_EACH, é impressa após de cada 
                    caso de teste da classe MeusTestes.</p>
                </section>
            </article>

            <section>
                <h3>Finalizando...</h3>
                
                <p>E assim chegamos ao final da visão geral sobre o xutest.</p>

                <p>Para um exemplo completo de uma calculadora de áreas com testes de unidade, 
                acesse: 
                    <a href="get-started/calculator-example.html">
                        calculadora - um exemplo completo
                    </a>.
                </p>
            </section>
        </section>        
    </main>
</div>

    <footer>
        <span id="footer"></span>
    </footer>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
    <script src="lib/prism/prism.js"></script>
</body>

</html>