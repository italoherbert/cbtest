<!DOCTYPE html>

<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Página oficial do xutest - get started - macros e asserts">
    <meta name="keyworks" content="xutest, testes, unitários, unidade, unit, test, windows, linux, cbuild, c, c++">
    <meta name="author" content="Ítalo Herbert Siqueira Gabriel">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css" rel="stylesheet">
    <link href="../lib/fontawesome/all.min.css" rel="stylesheet">
    <link href="../lib/prism/prism.css" rel="stylesheet">
    <link href="../style/style.css" rel="stylesheet">
    
    <title>Macros e asserts - xutest - Site oficial</title>

    <script src="../lib/jquery-3.7.1.min.js"></script>    
    <script src="../lib/fontawesome/all.min.js"></script>
    <script src="../js/main.js"></script>
</head>

<body>
    <nav id="nav"></nav>

<div class="d-flex flex-nowrap">
    <aside id="aside"></aside>
    <main>
        <article>
            <header>
                <h1 class="text-center">Macros e asserts</h1>
            </header>

            <article>
                <header>
                    <h3>A macro TEST_CASE</h3>
                </header>

                <p>Na macro TEST_CASE, fica a escrita do caso de teste em si. Isto é, as 
                chamadas as macros de ASSERT.</p>

                <p>O primeiro argumento passado a TEST_CASE, é o nome do caso de teste e o 
                segundo argumento (opcional) é o nome da classe do caso de teste. Se não 
                quiser informar, o caso de teste é vinculado a classe de nome "default" e, 
                a virgula após o nome do caso de teste é obrigatória, mesmo que, após a virgula, 
                não seja definido o nome da classe do caso de testes. Veja o exemplo abaixo: </p>

<pre class="line-numbers"><code class="language-cpp">TEST_CASE( primeiroTeste, MeusTestes ) {
    ASSERT_EQUALS( 1, 1, )
}
</code></pre>

            </article>

            <article>
                <header>
                    <h3>As macros de assert</h3>
                </header>

                <p>As macros de assert suportam uma mensagem personalizada a ser mostrada 
                no caso do assert falhar e não precisam ser finalizadas com ponto e vírgula.</p>

                <p>No caso da macro ser chamada, por exemplo, dentro de um if/else sem blóco de 
                código, é obrigatório não colocar o ponto e virgula no final da macro. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">bool condicao = true;
    if ( condicao )
        ASSERT_EQUALS( 1, 1, );
    else ASSERT_EQUALS( 1, 2, )
</code></pre>

                <p>O exemplo acima está errado porque há um ponto e virgula após a macro de 
                assert, e antes do else do if. O correto é retirar o ponto e virgula como a 
                seguir: </p>

<pre class="line-numbers"><code class="language-cpp">bool condicao = true;
    if ( condicao )
        ASSERT_EQUALS( 1, 1, )
    else ASSERT_EQUALS( 1, 2, )
</code></pre>

                <br />

                <section>
                    <h5>A macro ASSERT_EQUALS</h5>

                    <p>A macro de assert pode ser utilizada para testar se dois valores 
                    são iguais. Exemplos:</p>

<pre class="line-numbers"><code class="language-cpp">ASSERT_EQUALS( 1, 1, )

int a = 1;
int b = 1;
string c = "teste";
string d = "teste";

ASSERT_EQUALS( a, b, )
ASSERT_EQUALS( c, d, As strings não são iguais! )
</code></pre>          

                    <p>No exemplo acima, são comparadas duas variáveis inteiras e duas 
                    variáveis tipo string. Perceba que no último assert, é passada como 
                    terceiro argumento, uma mensagem. Essa mensagem é mostrada, apenas 
                    se o assert falhar. Perceba que a mensagem não está entre aspas duplas. 
                    As aspas duplas não são necessárias. Caso contrário, as aspas duplas 
                    também são impressas.</p>

                    <p>Perceba também que, os asserts sem a mensagem a ser mostrada em 
                    caso de falha, têm uma virgula após os parâmetros e antes do 
                    fecha parenteses. Essa virgula é necessária, mesmo que o terceiro argumento 
                    não seja informado. Isso vale para todas as macros de assert e a macro 
                    TEST_CASE.</p>
                </section>

                <br />

                <section>
                    <header>
                        <h5>A macro ASSERT_NOT_EQUALS</h5>
                    </header>

                    <p>É o contrário da macro ASSERT_EQUALS. Isto é, falha se os valores 
                    forem iguais. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">string str1 = "teste";
string str2 = "teste2";

ASSERT_NOT_EQUALS( str1, str2, )
</code></pre> 

                </section>

                <br />

                <section>
                    <header>
                        <h5>A macro ASSERT_EQUALS_ARRAYS</h5>
                    </header>

                    <p>A macro ASSERT_EQUALS_ARRAYS pode ser utilizada para testar 
                    se dois arrays são iguais. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">int arr1[] = { 1, 2, 3 };
int arr2[] = { 1, 2, 3 };

ASSERT_EQUALS_ARRAYS( arr1, arr2, 3, )
</code></pre> 

                    <p>Os asserts de arrays recebem um terceiro parâmetro adicional: o 
                    tamanho do array. No exemplo acima, os arrays têm 3 elementos cada.</p>
                </section>

                <br />

                <section>
                    <header>
                        <h5>A macro ASSERT_NOT_EQUALS_ARRAYS</h5>
                    </header>

                    <p>A macro ASSERT_NOT_EQUALS_ARRAYS pode ser utilizada para testar 
                    se dois arrays são diferentes. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">int arr1[] = { 1, 2, 3 };
int arr2[] = { 3, 2, 1 };

ASSERT_EQUALS_ARRAYS( arr1, arr2, 3, )
</code></pre> 
                </section>

                <br />

                <section>
                    <header>
                        <h5>A macro ASSERT_EQUALS_VECTORS</h5>
                    </header>

                    <p>A macro ASSERT_EQUALS_VECTORS pode ser utilizada para testar 
                    se dois vectors são iguais. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">vector<int> vect1 = { 1, 2, 3 };
vector<int> vect2 = { 1, 2, 3 };

ASSERT_EQUALS_VECTORS( vect1, vect2, )
</code></pre> 
                </section>

                <br />

                <section>
                    <header>
                        <h5>A macro ASSERT_NOT_EQUALS_VECTORS</h5>
                    </header>

                    <p>A macro ASSERT_NOT_EQUALS_VECTORS pode ser utilizada para testar 
                    se dois vectors são diferentes. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">vector<int> vect1 = { 1, 2, 3 };
vector<int> vect2 = { 3, 2, 1 };

ASSERT_NOT_EQUALS_VECTORS( vect1, vect2, )
</code></pre> 
                </section>

                <br />

                <section>
                    <h5>Atenção</h5>

                    <p>Você pode desabilitar, ou habilitar, a impressão dos vetores 
                    no caso de falha no assert. Isso é útil para evitar impressão de 
                    vetores, caso eles tenham muitos elementos, por exemplo.</p>

                    <p>Para habilitar, ou desabilitar a impressão de vetores 
                    (ou arrays) na falha do assert, utilize a seguinte função: </p>

<pre class="line-numbers"><code class="language-cpp">xutest::set_print_vectors( true ); // Para habilitar
xutest::set_imp_vectors( false );  // para desabilitar
</code></pre>

                    <p>Esta função <b>set_print_vectors</b> está no header <b>"xutest.h"</b> 
                    e no namespace <b>xutest</b>. Agora, veja abaixo dois exemplos: </p>

<pre class="line-numbers"><code class="language-cpp">xutest::set_print_vectors( true ); // Para habilitar

vector<int> vect1 = { 1, 2, 3 };
vector<int> vect2 = { 3, 2, 1 };

ASSERT_EQUALS_VECTORS( vect1, vect2, )
</code></pre>
                    <p>Os vetores são impressos, pois, o assert falha e a flag de impressão 
                    de vetores está setada para true. Setada através do método set_print_vectors</p>

<pre class="line-numbers"><code class="language-cpp">xutest::set_print_vectors( false ); // Para desabilitar

vector<int> vect1 = { 1, 2, 3 };
vector<int> vect2 = { 3, 2, 1 };

ASSERT_EQUALS_VECTORS( vect1, vect2, ) 
</code></pre>

                    <p>Os vetores não são impressos, pois, apesar de o assert falhar, a flag de impressão 
                    de vetores está setada para false.</p>
                </section>

                <br />

                <section>
                    <h5>A macro ASSERT_TRUE</h5>

                    <p>A macro assert true testa se uma condição é verdadeira. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">int a = 1;

ASSERT_TRUE( a > 0, )
</code></pre>
                </section>

                <br />

                <section>
                    <h5>A macro ASSERT_FALSE</h5>

                    <p>A macro assert false testa se uma condição é falsa. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">int a = 1;

ASSERT_FALSE( a == 0, )
</code></pre>
                </section>

                <br />

                <section>
                    <h5>A macro ASSERT_NULL</h5>

                    <p>A macro ASSERT_NULL testa se o ponteiro aponta 
                    para nullptr ou NULL. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">string* strptr = nullptr;

ASSERT_NULL( strptr, )
</code></pre>
                </section>

                <br />

                <section>
                    <h5>A macro ASSERT_NOT_NULL</h5>

                    <p>A macro ASSERT_NOT_NULL testa se o ponteiro não aponta, nem 
                    para nullptr, nem para NULL. Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">string* strptr = new string( "abc" );

ASSERT_NOT_NULL( strptr, )
</code></pre>
                </section>

                <br />

                <section>
                    <h5>A macro ASSERT_THROWS</h5>

                    <p>A macro ASSERT_THROWS testa se uma determinada exceção foi lançada. 
                    Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">ASSERT_THROWS( runtime_error, {
    // Código qualquer
    throw runtime_error( "XXX" );    // lança uma runtime_error
}, );
</code></pre>
                </section>

                <section>
                    <h5>A macro ASSERT_NOT_THROWS</h5>

                    <p>A macro ASSERT_THROWS testa se uma determinada exceção não foi lançada. 
                    Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">ASSERT_NOT_THROWS( runtime_error, {
    // Código qualquer
}, );
</code></pre>

                    <p>O assert passa se o código dentro do bloco de código do ASSERT_NOT_THROWS 
                    não lançar uma exceção "runtime_error".</p>

                </section>
    
            </article>

            <article>
                <header>
                    <h3>As macros BEFORE_ALL e AFTER_ALL</h3>
                </header>

                <p>As macros BEFORE_ALL e AFTER_ALL, podem ser usadas para definir um 
                bloco de código que deve ser executado antes de todos os testes da classe, 
                ou, após todos os testes da classe, respectivemante.</p>

                <section>
                    <h5>A macro BEFORE_ALL</h5>

                    <p>A macro BEFORE_ALL pode ser usada para definir o que deve ser 
                    executado antes de todos os testes da classe de casos de teste. 
                    Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">BEFORE_ALL( MeusTestes ) {
    cout &lt;&lt; "Iniciando os testes da classe de testes MeusTestes" &lt;&lt; endl;
}

TEST_CASE( teste1, MeusTestes ) {
    ASSERT_EQUALS( 1, 1, )
}

TEST_CASE( teste2, MeusTestes ) {
    ASSERT_TRUE( true, )
}
</code></pre>
                    <p>A mensagem do "cout" da definição BEFORE_ALL, é impressa antes de todos 
                    os testes da classe MeusTestes.</p>
                </section>

                <br />

                <section>
                    <h5>A macro AFTER_ALL</h5>

                    <p>A macro AFTER_ALL pode ser usada para definir o que deve ser 
                    executado depois de todos os testes da classe de casos de teste. 
                    Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">AFTER_ALL( MeusTestes ) {
    cout &lt;&lt; "Finalizando os testes da classe de testes MeusTestes" &lt;&lt; endl;
}
</code></pre>
                    <p>A mensagem do "cout" da definição AFTER_ALL, é impressa após de todos 
                    os testes da classe MeusTestes.</p>
                </section>
            </article>

            <article>
                <header>
                    <h3>As macros BEFORE_EACH e AFTER_EACH</h3>
                </header>

                <p>As macros BEFORE_EACH e AFTER_EACH, podem ser usadas para definir um 
                bloco de código que deve ser executado antes de cada caso de teste da classe, 
                ou, após cada caso de teste da classe, respectivemante.</p>

                <section>
                    <h5>A macro BEFORE_EACH</h5>

                    <p>A macro BEFORE_EACH pode ser usada para definir o que deve ser 
                    executado antes de cada caso de teste da classe de casos de teste. 
                    Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">BEFORE_EACH( MeusTestes ) {
    cout &lt;&lt; "Iniciando execução do caso de teste" &lt;&lt; endl;
}
</code></pre>
                    <p>A mensagem do "cout" da definição BEFORE_EACH, é impressa antes de cada  
                    caso de teste da classe MeusTestes.</p>
                </section>

                <br />

                <section>
                    <h5>A macro AFTER_EACH</h5>

                    <p>A macro AFTER_EACH pode ser usada para definir o que deve ser 
                    executado depois de cada caso de teste da classe de casos de teste. 
                    Exemplo: </p>

<pre class="line-numbers"><code class="language-cpp">AFTER_EACH( MeusTestes ) {
    cout &lt;&lt; "Finalizando a execução do caso de teste" &lt;&lt; endl;
}
</code></pre>
                    <p>A mensagem do "cout" da definição AFTER_EACH, é impressa após de cada 
                    caso de teste da classe MeusTestes.</p>
                </section>
            </article>

            <section>
                <h3>Próxima aula</h3>

                <p>O próxima aula ensina como criar um exemplo completo de uma calculadora.</p>
            </section>

            <footer class="d-flex justify-content-between">
                <a class="btn btn-dark" href="include-in-project.html">
                    Anterior
                </a>
                <a class="btn btn-dark" href="index.html">
                    Cima
                </a>
                <a class="btn btn-dark" href="calculator-example.html">
                    Proxima
                </a>            
            </footer>
        </article>
    </main>
</div>

    <footer>
        <span id="footer"></span>
    </footer>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
    <script src="../lib/prism/prism.js"></script>
</body>

</html>